<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>5kohlers - welcome</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<style>
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  background: black;
  overflow: hidden;
}
canvas { display: block; }
</style>
</head>

<body>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

const chars = " .:-=+*#%@█▓▒░";

let charWidth, charHeight;
let cols, rows;
let t = 0;

let sinX = [];
let cosY = [];

// --- colors ---
let fgColor = "#ff0000";
let bgColor = "#000000";

// --- ASCII overlay ---
const overlay = [
"888888P dP                dP       dP                            ",
"88'     88                88       88                            ",
"88baaa. 88  .dP  .d8888b. 88d888b. 88 .d8888b. 88d888b. .d8888b. ",
"    `88 88888\"   88'  `88 88'  `88 88 88ooood8 88'  `88 Y8ooooo. ",
"     88 88  `8b. 88.  .88 88    88 88 88.  ... 88             88 ",
"d88888P dP   `YP `88888P' dP    dP dP `88888P' dP       `88888P'  "
];

const overlay_wrap = [
"888888P dP                dP      ",
"88'     88                88      ",
"88baaa. 88  .dP  .d8888b. 88d888b.",
"    `88 88888\"   88'  `88 88'  `88",
"     88 88  `8b. 88.  .88 88    88 ",
"d88888P dP   `YP `88888P' dP    dP ",
" ",
"  dP                            ",
"  88                            ",
"  88 .d8888b. 88d888b. .d8888b. ",
"  88 88ooood8 88'  `88 Y8ooooo. ",
"  88 88.  ... 88             88 ",
"  dP `88888P' dP       `88888P'  "
];

let overlay_used = overlay;

//let globalScale = 1;

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // --- compute scale if screen is narrow ---
  const threshold = 550; // px
  if (canvas.width < threshold) {
    //globalScale = canvas.width / threshold; // scale < 1
	overlay_used = overlay_wrap;
  } else {
    //globalScale = 1;
	overlay_used = overlay;
  }

  //ctx.setTransform(globalScale, 0, 0, globalScale, 0, 0); // apply scale

  ctx.font = "14px monospace";
  ctx.textBaseline = "top";

  charWidth = ctx.measureText("X").width;
  charHeight = 13;

  cols = Math.floor(canvas.width / charWidth);
  rows = Math.floor(canvas.height / charHeight);

  sinX.length = cols;
  cosY.length = rows;
}



function resize_backup() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  ctx.font = "14px monospace";
  ctx.textBaseline = "top";

  charWidth = ctx.measureText("X").width;
  charHeight = 13;

  cols = Math.floor(canvas.width / charWidth);
  rows = Math.floor(canvas.height / charHeight);

  sinX.length = cols;
  cosY.length = rows;
}

// cheap hash for pseudo-random per-cell values
function hash(x, y) {
  return ((x*374761393 + y*668265263) >>> 0) % 1000 / 1000;
}

// --- HISTORY ---
const colorHistory = [];
let historyIndex = -1;

setColors(fgColor, bgColor);

// --- update colors and push to history ---
function setColors(fg, bg) {
  fgColor = fg;
  bgColor = bg;

  // if we're not at the end, truncate forward history
  if (historyIndex < colorHistory.length - 1) {
    colorHistory.splice(historyIndex + 1);
  }

  colorHistory.push({ fg, bg });
  if (colorHistory.length > 100) colorHistory.shift(); // keep max n
  historyIndex = colorHistory.length - 1;
}

// --- override random color changes to go through history ---
function applyRandomColors() {
  const fg = randomColor();
  const bg = randomColor();
  setColors(fg, bg);
}

// generate random color in hex
function randomColor() {
  const r = Math.floor(Math.random()*256);
  const g = Math.floor(Math.random()*256);
  const b = Math.floor(Math.random()*256);
  return `rgb(${r},${g},${b})`;
}

// random color generator, maintaining min contrast
function randomColorMinContrast() {
  const h = Math.floor(Math.random() * 360);
  const s = 70 + Math.random() * 30;
  const l = 40 + Math.random() * 30;
  return `hsl(${h}, ${s}%, ${l}%)`;
}

function forwardNavColor() {
    if (historyIndex < colorHistory.length - 1) {
      historyIndex++;
      const { fg, bg } = colorHistory[historyIndex];
      fgColor = fg;
      bgColor = bg;
    } else {
      applyRandomColors();
    }
};

function backwardNavColor() {
    if (historyIndex > 0) {
      historyIndex--;
      const { fg, bg } = colorHistory[historyIndex];
      fgColor = fg;
      bgColor = bg;
    }
};

// --- key handler ---
window.addEventListener("keydown", e => {
  if (e.key === "ArrowLeft") {
    // LEFT: navigate back in history
    backwardNavColor()
  }
});

window.addEventListener("keydown", e => {
  if (e.key === "ArrowRight") {
    // RIGHT: navigate forward in history
    forwardNavColor()
  }
});


// --- mouse click handler for left/right navigation ---
canvas.addEventListener("click", e => {
  const x = e.clientX;

  if (x < canvas.width / 2) {
    // LEFT: navigate back in history
    backwardNavColor()
  } else {
    // RIGHT: navigate forward in history or generate new
    forwardNavColor();
  }
});

function frame() {
  // background
  ctx.fillStyle = bgColor;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const angle = t * 0.002;
  const speed = 0.06;
  const dx = Math.cos(angle) * speed;
  const dy = Math.sin(angle) * speed;

  for (let x = 0; x < cols; x++) sinX[x] = Math.sin(x*0.15 + t*0.1);
  for (let y = 0; y < rows; y++) cosY[y] = Math.cos(y*0.15 + t*0.13);

  const cx = cols / 2;
  const cy = rows / 2;

  ctx.fillStyle = fgColor;

  // --- background pattern ---
  for (let y = 0; y < rows; y++) {
    let row = "";
    const y0 = y - cy;
    const cy0 = cosY[y];

    for (let x = 0; x < cols; x++) {
      const x0 = x - cx;

      const base = sinX[x] + cy0 + Math.sin((x + y)*0.1 + t*0.07);

      const r = hash(x, y);
      const micro =
        Math.sin(x*9.1 + y*4.7 + t*0.05 + r*6.28) * 0.25 +
        Math.sin(x*2.3 + y*3.5 + t*0.1 + r*12.57) * 0.15 +
        Math.sin(x*7.7 + y*5.1 + t*0.08 + r*3.14) * 0.1;

      let v = base + micro + dx*x0 + dy*y0;
      v += (Math.random() - 0.5) * 0.15;

      const value = Math.sign(v) * Math.pow(Math.abs(v), 1.2);
      const index = Math.floor(((value + 3) / 6) * (chars.length - 1));
      row += chars[Math.max(0, Math.min(chars.length - 1, index))];
    }
    ctx.fillText(row, 0, y * charHeight);
  }

  // --- centered, pattern-revealed overlay ---
  //ctx.fillStyle = "#000000"; // static black
  const maxLen = Math.max(...overlay_used.map(l => l.length));
  const overlayWidth = maxLen * charWidth;
  const overlayHeight = overlay_used.length * charHeight;

  const ox = (canvas.width - overlayWidth) / 2;
  const oy = (canvas.height - overlayHeight) / 2;

  const revealThreshold = 0.9;
  
  //ctx.globalAlpha = 0.6;
  //ctx.fillStyle = fgColor;

  for (let ly = 0; ly < overlay_used.length; ly++) {
    const line = overlay_used[ly];
    const gy = Math.floor((oy + ly * charHeight) / charHeight);
    if (gy < 0 || gy >= rows) continue;

    let out = "";
    for (let i = 0; i < line.length; i++) {
      const gx = Math.floor((ox + i * charWidth) / charWidth);
      if (gx < 0 || gx >= cols || line[i] === " ") {
        out += " ";
        continue;
      }

      const strength = Math.abs(
        sinX[gx] +
        cosY[gy] +
        Math.sin((gx + gy)*0.1 + t*0.07)
      );

      out += strength > revealThreshold ? line[i] : " ";
    }

    ctx.fillText(out, ox, oy + ly * charHeight);
  }
  
  //ctx.globalAlpha = 1;

  t += 0.75; // MACRO MOVEMENT SPEED
  requestAnimationFrame(frame);
}

resize();
window.addEventListener("resize", resize);
frame();
</script>
</body>
</html>
