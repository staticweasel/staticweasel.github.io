<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>5kohlers - welcome</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  background: black;
  overflow: hidden;
}
canvas { display: block; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

const chars = " .:-=+*#%@█▓▒░";

// ASCII overlay text
const overlayText = [
"888888P dP                dP       dP                            ",
"88'     88                88       88                            ",
"88baaa. 88  .dP  .d8888b. 88d888b. 88 .d8888b. 88d888b. .d8888b. ",
"    `88 88888\"   88'  `88 88'  `88 88 88ooood8 88'  `88 Y8ooooo. ",
"     88 88  `8b. 88.  .88 88    88 88 88.  ... 88             88 ",
"d88888P dP   `YP `88888P' dP    dP dP `88888P' dP       `88888P' "
];

let charWidth, charHeight;
let cols, rows;
let t = 0;
let fgColor = "#ff0000";
let bgColor = "black";

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  ctx.font = "14px monospace";
  ctx.textBaseline = "top";

  charWidth = ctx.measureText("X").width;
  charHeight = 13;

  cols = Math.floor(canvas.width / charWidth);
  rows = Math.floor(canvas.height / charHeight);
}

// cheap hash for pseudo-random per-cell values
function hash(x, y) {
  return ((x*374761393 + y*668265263) >>> 0) % 1000 / 1000;
}

// --- HISTORY ---
const colorHistory = [];
let historyIndex = -1;

setColors(fgColor, bgColor);

// --- update colors and push to history ---
function setColors(fg, bg) {
  fgColor = fg;
  bgColor = bg;

  // if we're not at the end, truncate forward history
  if (historyIndex < colorHistory.length - 1) {
    colorHistory.splice(historyIndex + 1);
  }

  colorHistory.push({ fg, bg });
  if (colorHistory.length > 100) colorHistory.shift(); // keep max n
  historyIndex = colorHistory.length - 1;
}

// --- override random color changes to go through history ---
function applyRandomColors() {
  const fg = randomColor();
  const bg = randomColor();
  setColors(fg, bg);
}

// generate random color in hex
function randomColor() {
  const r = Math.floor(Math.random()*256);
  const g = Math.floor(Math.random()*256);
  const b = Math.floor(Math.random()*256);
  return `rgb(${r},${g},${b})`;
}

function forwardNavColor() {
    if (historyIndex < colorHistory.length - 1) {
      historyIndex++;
      const { fg, bg } = colorHistory[historyIndex];
      fgColor = fg;
      bgColor = bg;
    } else {
      applyRandomColors();
    }
};

function backwardNavColor() {
    if (historyIndex > 0) {
      historyIndex--;
      const { fg, bg } = colorHistory[historyIndex];
      fgColor = fg;
      bgColor = bg;
    }
};

// --- key handler ---
window.addEventListener("keydown", e => {
  if (e.key === "ArrowLeft") {
    // LEFT: navigate back in history
    backwardNavColor()
  }
});

window.addEventListener("keydown", e => {
  if (e.key === "ArrowRight") {
    // RIGHT: navigate forward in history
    forwardNavColor()
  }
});


// --- mouse click handler for left/right navigation ---
canvas.addEventListener("click", e => {
  const x = e.clientX;

  if (x < canvas.width / 2) {
    // LEFT: navigate back in history
    backwardNavColor()
  } else {
    // RIGHT: navigate forward in history or generate new
    forwardNavColor();
  }
});

function frame() {
  // --- compute global scale to fit overlay ---
  const overlayCols = overlayText[0].length;
  const overlayRows = overlayText.length;
  const scaleX = cols / overlayCols;
  const scaleY = rows / overlayRows;
  const scale = Math.min(scaleX, scaleY, 1); // don't upscale beyond 1

  const scaledCharWidth = charWidth * scale;
  const scaledCharHeight = charHeight * scale;
  const scaledCols = Math.floor(cols / scale);
  const scaledRows = Math.floor(rows / scale);
  const cx = scaledCols/2;
  const cy = scaledRows/2;

  ctx.fillStyle = bgColor;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const angle = t * 0.002;
  const speed = 0.06;
  const dx = Math.cos(angle) * speed;
  const dy = Math.sin(angle) * speed;

  for(let y=0; y<scaledRows; y++){
    let row = "";
    for(let x=0; x<scaledCols; x++){
      const x0 = x-cx;
      const y0 = y-cy;
      const base = Math.sin(x*0.15 + t*0.1) + Math.cos(y*0.15 + t*0.13) + Math.sin((x+y)*0.1 + t*0.07);
      const r = hash(x,y);
      const micro = Math.sin(x*9.1 + y*4.7 + t*0.05 + r*6.28)*0.25 +
                    Math.sin(x*2.3 + y*3.5 + t*0.1 + r*12.57)*0.15 +
                    Math.sin(x*7.7 + y*5.1 + t*0.08 + r*3.14)*0.1;
      let drifted = base + micro + dx*x0 + dy*y0;
      const flatNoise = (Math.random()-0.5)*0.15;
      drifted += flatNoise;
      const value = Math.sign(drifted) * Math.pow(Math.abs(drifted), 1.2);
      const index = Math.floor(((value+3)/6)*(chars.length-1));
      row += chars[Math.max(0, Math.min(chars.length-1,index))];
    }
    ctx.save();
    ctx.scale(scale, scale);
    ctx.fillStyle = fgColor;
    ctx.fillText(row,0,y*charHeight);
    ctx.restore();
  }

  // --- overlay in slightly darker color ---
  //ctx.globalAlpha = 0.6;
  ctx.fillStyle = fgColor;
  const startX = Math.floor((scaledCols-overlayCols)/2) * scaledCharWidth;
  const startY = Math.floor((scaledRows-overlayRows)/2) * scaledCharHeight;
  ctx.save();
  ctx.scale(scale, scale);
  for(let i=0; i<overlayText.length; i++){
    ctx.fillText(overlayText[i], startX/scale, startY/scale + i*charHeight);
  }
  ctx.restore();
  //ctx.globalAlpha = 1;

  t++;
  requestAnimationFrame(frame);
}

resize();
frame();
</script>
</body>
</html>
